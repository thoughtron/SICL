(cl:in-package #:sicl-sequence)

(defmethod mismatch ((list1 list) (list2 list)
                     &key from-end test test-not key (start1 0) (start2 0) end1 end2)
  (multiple-value-bind (start1 end1)
      (canonicalize-start-and-end list1 start1 end1)
    (multiple-value-bind (start2 end2)
        (canonicalize-start-and-end list2 start2 end2)
      (let* ((size1 (- end1 start1))
             (size2 (- end2 start2))
             (limit (min size1 size2)))
        (declare (list-length size1 size2 limit))
        (with-test-function (test test test-not)
          (with-key-function (key key)
            (if (not from-end)
                ;; Scan from left to right.
                (loop for count fixnum below limit
                      for elt1 in (nthcdr start1 list1)
                      for elt2 in (nthcdr start2 list2)
                      unless (test (key elt1) (key elt2))
                        return (+ start1 count)
                      finally (if (= size1 size2)
                                  (return nil)
                                  (return (+ start1 limit))))
                ;; Scan from right to left.
                (loop for count fixnum below limit
                      for elt1 in (nreverse (subseq list1 (- end1 limit) end1))
                      for elt2 in (nreverse (subseq list2 (- end2 limit) end2))
                      unless (test (key elt1) (key elt2))
                        return (- end1 count)
                      finally (if (= size1 size2)
                                  (return nil)
                                  (return (- end1 limit)))))))))))

(replicate-for-each-vector-class #1=#:vector-class
  (defmethod mismatch ((list list) (vector #1#)
                       &key from-end test test-not key (start1 0) (start2 0) end1 end2)
    (multiple-value-bind (start1 end1)
        (canonicalize-start-and-end list start1 end1)
      (multiple-value-bind (start2 end2)
          (canonicalize-start-and-end vector start2 end2)
        (let* ((size1 (- end1 start1))
               (size2 (- end2 start2))
               (limit (min size1 size2)))
          (declare (list-length size1 size2 limit))
          (with-test-function (test test test-not)
            (with-key-function (key key)
              (if (not from-end)
                  ;; Scan from left to right.
                  (loop for count fixnum below limit
                        for elt1 in (nthcdr start1 list)
                        for elt2 = (elt vector (+ start2 count))
                        unless (test (key elt1) (key elt2))
                          return (+ start1 count)
                        finally (if (= size1 size2)
                                    (return nil)
                                    (return (+ start1 limit))))
                  ;; Scan from right to left.
                  (loop for count fixnum below limit
                        for elt1 in (nreverse (subseq list (- end1 limit) end1))
                        for elt2 = (elt vector (- end2 count 1))
                        unless (test (key elt1) (key elt2))
                          return (- end1 count)
                        finally (if (= size1 size2)
                                    (return nil)
                                    (return (- end1 limit))))))))))))

(replicate-for-each-vector-class #1=#:vector-class
  (defmethod mismatch ((vector #1#) (list list)
                       &key from-end test test-not key (start1 0) (start2 0) end1 end2)
    (multiple-value-bind (start1 end1)
        (canonicalize-start-and-end vector start1 end1)
      (multiple-value-bind (start2 end2)
          (canonicalize-start-and-end list start2 end2)
        (let* ((size1 (- end1 start1))
               (size2 (- end2 start2))
               (limit (min size1 size2)))
          (declare (list-length size1 size2 limit))
          (with-test-function (test test test-not)
            (with-key-function (key key)
              (if (not from-end)
                  ;; Scan from left to right.
                  (loop for count fixnum below limit
                        for elt1 = (elt vector (+ start1 count))
                        for elt2 in (nthcdr start2 list)
                        unless (test (key elt1) (key elt2))
                          return (+ start1 count)
                        finally (if (= size1 size2)
                                    (return nil)
                                    (return (+ start1 limit))))
                  ;; Scan from right to left.
                  (loop for count fixnum below limit
                        for elt1 = (elt vector (- end1 count 1))
                        for elt2 in (nreverse (subseq list (- end2 limit) end2))
                        unless (test (key elt1) (key elt2))
                          return (- end1 count)
                        finally (if (= size1 size2)
                                    (return nil)
                                    (return (- end1 limit))))))))))))

(replicate-for-each-vector-class #1=#:vector-class
  (defmethod mismatch ((vector1 #1#) (vector2 #1#)
                       &key from-end test test-not key (start1 0) (start2 0) end1 end2)
    (multiple-value-bind (start1 end1)
        (canonicalize-start-and-end vector1 start1 end1)
      (multiple-value-bind (start2 end2)
          (canonicalize-start-and-end vector2 start2 end2)
        (let* ((size1 (- end1 start1))
               (size2 (- end2 start2))
               (limit (min size1 size2)))
          (declare (list-length size1 size2 limit))
          (with-test-function (test test test-not)
            (with-key-function (key key)
              (if (not from-end)
                  ;; Scan from left to right.
                  (loop for count fixnum below limit
                        for elt1 = (elt vector1 (+ start1 count))
                        for elt2 = (elt vector2 (+ start2 count))
                        unless (test (key elt1) (key elt2))
                          return (+ start1 count)
                        finally (if (= size1 size2)
                                    (return nil)
                                    (return (+ start1 limit))))
                  ;; Scan from right to left.
                  (loop for count fixnum below limit
                        for elt1 = (elt vector1 (- end1 count 1))
                        for elt2 = (elt vector2 (- end2 count 1))
                        unless (test (key elt1) (key elt2))
                          return (- end1 count)
                        finally (if (= size1 size2)
                                    (return nil)
                                    (return (- end1 limit))))))))))))
