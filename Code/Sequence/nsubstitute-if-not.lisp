(cl:in-package #:sicl-sequence)

(defmethod nsubstitute-if-not (newitem predicate (list list)
                               &key from-end (start 0) end count key)
  (let ((count (canonicalize-count count))
        (n-substituted 0))
    (with-predicate (predicate predicate)
      (with-key-function (key key)
        (unless (zerop count)
          (for-each-relevant-cons (cons index list start end from-end)
            (unless (predicate (key (car cons)))
              (setf (car cons) newitem)
              (incf n-substituted)
              (when (= n-substituted count)
                (return-from nsubstitute-if-not list)))))
        list))))

(seal-domain #'nsubstitute-if-not '(t t list))

(replicate-for-each-vector-class #1=#:vector-class
  (defmethod nsubstitute-if-not (newitem predicate (vector #1#)
                             &key from-end (start 0) end count key)
    (let ((count (canonicalize-count count))
          (n-substituted 0))
      (with-predicate (predicate predicate)
        (with-key-function (key key)
          (unless (zerop count)
            (for-each-relevant-element (element index vector start end from-end)
              (unless (predicate (key element))
                (setf element newitem)
                (incf n-substituted)
                (when (= n-substituted count)
                  (return-from nsubstitute-if-not vector)))))
          vector)))))

(seal-domain #'nsubstitute-if-not '(t t vector))
