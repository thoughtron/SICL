\chapter{Data representation}
\label{chap-data-representation}

\section{Low-level tag bits}

The three least significant bits of a machine word are used to
represent four different \emph{tags} as follows:

\begin{itemize}
\item \texttt{000}, \texttt{010}, \texttt{100}, \texttt{110}.  These
  tags are used for fixnums.  The bits except the last one represent
  integer in two's complement representation.  On a 64-bit machine, a
  fixnum is thus in the interval $[2^{-62}, 2^{62} - 1]$.
\item \texttt{001}.  This tag is used for \texttt{cons} cells.  A
  pointer to a \texttt{cons} cell is thus a pointer aligned to a
  double word to which the machine integer $1$ has been added.  See
  \refSec{sec-data-representation-cons-cells} for more information
  about the representation of \texttt{cons} cells.
\item \texttt{011}.  This tag is used for various \emph{immediate}
  objects, and in particular for \emph{characters}.
  \seesec{sec-data-representation-immediate-objects}
\item \texttt{101}.  This tag is used for all heap-allocated
  \commonlisp{} objects other than \texttt{cons} cells.  A heap
  allocated object like this is a \emph{standard object}.  It
  is represented by a two-word header object with one word containing
  a tagged pointer to the \emph{class object} and the other word
  containing a tagged pointer to the \emph{rack}.  See
  \refSec{sec-data-representation-standard-object} for more
  information about the representation of standard objects.
\item \texttt{111}.  This tag is used to tag a pointer to a
  \emph{rack}.  Notice that a rack is not a first-class \commonlisp{}
  object, so it can not be the value of any variable, slot, or
  argument.
\end{itemize}

On a 64-bit machine, floats of type \texttt{short-float} and
\texttt{single-float} are represented as immediate values.

\section{Immediate objects}
\label{sec-data-representation-immediate-objects}

Immediate objects are all objects with \texttt{011} in the lower three
bits.  Two more bits are used to distinguish between different kinds
of immediate objects, giving the following five low bits:

\begin{itemize}
\item \texttt{00011}.  This tag is used for Unicode characters.  When
  shifted five positions to the right, the value gives the Unicode
  code point.
\item \texttt{01011}.  This tag is used short floats.
\item \texttt{10011}.  This tag is used for single floats (64-bit
  platforms only).
\item \texttt{11011}.  This tag is unused.
\end{itemize}

\subsection{Characters}

As indicated above, the low five bits of a character have the value
\texttt{00011}, and the corresponding Unicode code point is obtained by
shifting the value of the character five positions to the right.

We currently do not plan to supply a module for Unicode support.
Instead we are relying on the support available in the Unicode library
by Edi Weitz.

\subsection{Single floats}

On a 64-bit platform, a single float corresponds to a single-precision
IEEE floating-point value.  The value is stored in the
most-significant half of the word.

\section{Representation of \texttt{cons} cells}
\label{sec-data-representation-cons-cells}

A \texttt{cons} cell is represented as two consecutive machine
words aligned on a double-word boundary.

\section{Representation of standard objects}
\label{sec-data-representation-standard-object}

Recall that a \emph{standard object} is a heap allocated object that
is not a \texttt{cons} cell.  All standard objects are represented in
(at least) two parts, a \emph{header object} and a \emph{rack}.  The
header object always consists of two consecutive words aligned on a
double-word boundary (just like \texttt{cons} cells).  The first word
always contains a tagged pointer to a \emph{class} object (which is
another standard object).  The second word contains a tagged pointer
(with tag $111$) to the first word of the rack.

The first entry of the rack of every standard object is a
small fixnum called the \emph{stamp} of the standard object.  The
stamp is the \emph{unique class number} of the class of the general
instance as it was when the instance was created.  The main purpose of
this information is to be used in \emph{generic function dispatch}.
It is also used to determine whether a standard object is an obsolete
instance (in this case the stamp of the standard object will not be
the same as the \emph{current} unique class number of the class of the
standard object).  Standard objects that can become obsolete are
said to be \emph{flexible}.

One advantage of representing standard objects this way is that the
rack is \emph{internally consistent}.  To explain what we
mean by this concept, let us take an \emph{adjustable array} as an
example.  The implementation of \texttt{aref} must check that the
indices are valid, compute the offset of the element and then access
the element.  But in the presence of threads, between the index check
and the access, some other thread might have adjusted the array so
that the indices are no longer valid.  In most implementations, to
ensure that \texttt{aref} is \emph{thread safe}, it is necessary to
prevent other threads from intervening between the index check and the
access, for instance by using a \emph{lock}.  In \sysname{}, adjusting
the array involves creating a new rack with new dimensions,
and then with a single store instruction associate the new rack
with the array.  The implementation of \texttt{aref} would then
initially obtain a pointer to the rack and then do the
index check, the computation of the offset, and the access without
risking any interference.  No locking is therefore required.  Another
example is a \emph{generic function}.  When a method is added or
deleted, or when a new sequence of argument classes is seen, the
generic function must be destructively updated.  Normally, this
operation would require some locking primitive in order to prevent
other threads from invoking a partially updated generic function.  In
\sysname{}, to update a generic function this way, a new rack
would be allocated and the modifications would be made there,
leaving the original generic function intact until the final
instruction to store a reference to the the new rack in the
header object.

A standard object can be \emph{rigid} or \emph{flexible}.  A rigid
instance is an instance of a class that can not change, typically a
system class.  A flexible instance is an instance of a class that may
be modified, makings its instances \emph{obsolete}.  In \sysname{},
structure objects are flexible too.

In the following sections we give the details of the representation
for all possible standard objects.

\section{Flexible instances}
\label{sec-data-representation-flexible-instances}

A flexible instance must allow for its class to be redefined, making
it necessary for the instance to be updated before being used again.  The
standard specifically allows for these updates to be delayed and not
happen as a direct result of the class redefinition.  They must happen
before an attempt is made to access some slot (or some other
information about the slots) of the instance.  It is undesirable to
make all instances directly accessible from the class, because
such a solution would waste space and would have to make sure that
memory leaks are avoided.  We must thus take into account the presence
of \emph{obsolete instance} in the system, i.e. instances that must
be \emph{updated} at some later point in time.

The solution is to store some kind of \emph{version} information in
the rack so that when an attempt is made to access an
obsolete instance, the instance can first be updated to correspond to
the current definition of its class.  This version information must
allow the system to determine whether any slots have been added or
removed since the instance was created.  Furthermore, if the garbage
collector traces an obsolete instance, then it must either first
update it, or the version information must allow the garbage collector
to trace the obsolete version of the instance.  Our solution allows
both.  We simply store a reference to the \emph{list of effective
  slots} that the class of the instance defined when the instance was
created.  This reference is stored as the \emph{second} word of the
rack (recall that the first word is taken up by the
\emph{stamp}).

This solution makes it possible to determine the layout of the rack of
an obsolete instance, so that it can be traced by the garbage
collector when necessary.  This solution also allows the system to
determine which slots have been added and which slots have been
removed since the instance was created.  In order to detect whether an
object is obsolete, the contents of the first word of the rack
(i.e. the \emph{stamp}) is compared to the \emph{class unique number}
of the class of the object.  However, this test is performed
automatically in most cases, because when an obsolete object is passed
as an argument to a generic function, the \emph{automation} of the
discriminating function of the generic function will fail to find an
effective method, triggering an update of the object.
\seesec{sec-generic-function-dispatch-the-discriminating-function}

\section{Funcallable standard objects}
\label{sec-data-representation-funcallable-standard-objects}

By definition, a \emph{funcallable standard object} is an instance of
a subclass of the class \texttt{funcallable-standard-object} which is
itself a subclass of the class \texttt{standard-object} and of the
class \texttt{function}. \seesec{sec-data-representation-functions}

To make function invocation fast, we want every subclass of the class
\texttt{function} to be invoked in the same way, i.e. by loading the
\emph{static environment} into a register and then transferring
control to the \emph{entry point} of the function. The static
environment and the entry point are stored in the function object
and are loaded into registers as part of the function-call protocol.

When the funcallable standard object is a generic function, invoking
it amounts to transferring control to the \emph{discriminating
  function}.  However, the discriminating function can not \emph{be}
the generic function, because the \clos{} specification requires that
the discriminating function of a generic function can be replaced,
without changing the identity of the generic function itself.
Furthermore, the discriminating function does not have to be stored in
a slot of the generic function, because once it is computed and
installed, it is no longer needed.  In order for the generic function
itself to behave in exactly the same way as its discriminating
function, whenever a new discriminating function is \emph{installed},
the \emph{entry point} and the \emph{static environment} are copied
from the discriminating function to the corresponding slots of the
generic function itself.

\section{Code objects}
\label{data-representation-code-objects}

A \emph{code object} is a standard object that represents the
\emph{code} of a function.  Recall that a function consists of some
code and an environment.  The code object is common to all functions
that share the same code.

The tables described below that are meant for the garbage collector
have entries only for the values of the program counter corresponding
to function calls.  At every \emph{safe point} the thread tests the
flag \texttt{gc-requested} described in
\refSec{sec-garbage-collection-synchronization-between-collectors}.
If that flag is set, a function call is made to the local garbage
collector.  Therefore, every safe point corresponds to a function
call, and thus the information is needed by the garbage collector only
at function calls.

A code object contains the following information:

\begin{itemize}
\item The executable native instructions in the form of a vector of
  unsigned bytes.
\item Tables providing support for commands of the debugger.  See
  below for more detailed information about these tables.
\item A hash table mapping a value of the program counter to a
  \emph{frame map}.  A frame map is a bitmap containing information
  that is used by the garbage collector to determine which stack
  locations contain \commonlisp{} objects that should be traced.
  Stack locations containing data owned by the current function
  invocation are present in the table.  A frame map never contains a
  stack location used to store a callee-saves register, because
  whether such a location contains a \commonlisp{} object or some
  other datum is determined by the caller of the current function.
  The compiler may omit stack locations that are known to contain
  immediate \commonlisp{} objects that the garbage collector does not
  have to trace.  For a typical backend, index $i$ of the bitmap
  represents the stack location at address $b-i$ where $b$ is the
  value of the base pointer.
\item A hash table mapping a value of the program counter to a
  \emph{callee-saves register map}.  This map is a bitmap which has as
  many elements as there are callee-saves registers.  A bit in the
  bitmap is set if the corresponding callee-saves register contains a
  \commonlisp{} object that may need to be traced by the garbage
  collector.  The compiler may put a cleared bit in the bitmap for a
  register known to contain an immediate \commonlisp{} object that the
  garbage collector does not need to trace.
\item A hash table mapping a value of the program counter to a
  \emph{callee-saves stack map}.  This map is indexed by a
  callee-saved register and contains a stack location in which the
  contents of the saved register was stored before the current
  function could use the register.  For a typical backend such as
  x86-64, the entries in the table represent the registers
  \texttt{RBX} (index 0), \texttt{R12} (index 1), \texttt{R13} (index
  2), \texttt{R14} (index 3), and \texttt{R15} (index 4) as described
  in \refSec{sec-backend-x86-84-register-use}.  The value of an entry
  represents the value to subtract from the value of the base pointer
  in order to get the stack location of the saved register.  A value
  of $0$ indicates that the register is not used by this function at
  this program point, i.e. either current function did not save the
  register, or it restored the register after having finished using
  it,
\item A vector of strings representing the source code of the
  compilation unit of which this code object is part.  Each string
  corresponds to a line of code.
\item Information about the file that contains the source code of the
  compilation unit of which this code object is part.
\item The \emph{concrete syntax tree} corresponding to the source code
  of the compilation unit of which this code object is part.
\end{itemize}

The following tables are used for debugger support:

\begin{itemize}
\item A table mapping source locations (i.e. line and column
  information corresponding to the location in the source code of the
  expression being evaluated) to values of the program counter.  When
  the user of the debugger sets a breakpoint at a particular source
  location, the debugger uses this information to determine a value of
  the program counter at which the program should stop its execution.
\item A table mapping values of the program counter to \emph{variable
  liveness information}.
\end{itemize}

\section{Rigid instances}
\label{sec-data-representation-rigid-instances}

Contrary to flexible instances, a \emph{rigid instance} is an instance
of a class that is not allowed to change after the first instance is
created.  Some system classes are examples of such classes.  The class
definition might change as long as there are no instances, but the
consequences are undefined if a system class is changed after it has
been instantiated.

\section{Instances of built-in classes}

The only direct instances of built-in classes are fixnums, characters,
short floats, single floats, and \texttt{cons} cells.

\subsection{Instances of \texttt{sequence}}

The system class \texttt{sequence} can not be directly instantiated.
Instead, it serves as a superclass for the classes \texttt{list} and
\texttt{vector}.

The \hs{} is a bit contradictory here, because
in some places it says that \texttt{list} and \texttt{vector}
represent an exhaustive partition of \texttt{sequence}%
\footnote{See for instance section 17.1}
but in other places it explicitly allows for other subtypes of
\texttt{sequence}.%
\footnote{See the definition of the system class \texttt{sequence}.}
The general consensus seems to be that other subtypes are allowed.

\subsection{Arrays}
\label{sec-data-representation-arrays}

Arrays are standard objects.  As a consequence, the exact layout of
the rack of an array is determined by the MOP machinery for computing
the slots when the class is finalized.  All arrays are simple.

Every array class has a slot \texttt{dimensions} that contains a list
of dimensions.  The length of the list is the \emph{rank} of the
array.

The element-type is determined by the exact subclass of the
\texttt{array} class.  The elements follow the explicit slots in the
rack.  The size of the rack is rounded up to the nearest multiple of a
word.

All arrays are \emph{adjustable} thanks to the split representation
with a header object and a rack.  Adjusting the array
typically requires allocating a new rack.

Specialized array classes with the following element types are
provided:

\begin{itemize}
\item \texttt{double-float}
\item \texttt{(unsigned-byte 64)}.
\item \texttt{(signed-byte 64)}.
\item \texttt{(unsigned-byte 32)}.
\item \texttt{(signed-byte 32)}.
\item \texttt{(unsigned-byte 8)}, used for code, interface with the
  operating system, etc.
\item \texttt{character} (i.e. strings) as required by the \hs{}.
\item \texttt{bit}, as required by the \hs{}.
\end{itemize}

Since the element type determines where an element is located and how
to access it, \texttt{row-major-aref} and \texttt{(setf
  row-major-aref)} are \emph{generic functions} that specialize on the
type of the array.

\subsubsection{System class \texttt{vector}}

A vector is a one-dimensional array.  As such, a vector has a rack
where \texttt{dimensions} slot contains a proper list of a single
element, namely the \emph{length} of the vector represented as a
fixnum.

All vectors have a slot for the \emph{fill pointer}.  This slot
contains \texttt{nil} for vectors without a fill pointer.

\subsubsection{System class \texttt{string}}

Tentatively, we think that there is no need to optimize strings that
contain only characters that could be represented in a single byte.

\subsection{Symbols}

A symbol is a standard object.  It has slots containing the following
data:

\begin{enumerate}
\item The \emph{name} of the symbol.  The value of this slot is a
  string.
\item The \emph{package} of the symbol.  The value of this slot is a
  package or \texttt{NIL} if this symbol does not have a package.
\end{enumerate}

Notice that the symbol does not contain its \emph{value} as a global
variable, nor does it contain its definition as a \emph{function} in
the global environment.  Instead, this information is contained in an
explicit \emph{global environment} object.

Notice also that the symbol does not contain the \emph{property list}
associated with it.  This information is also kept separately in an
explicit \emph{global environment} object.

See \refSec{sec-the-global-environment} for more information on
global environments.

\subsection{Packages}

A package is a standard object with the following slots:

\begin{enumerate}
\item The \emph{name} of the package.  The value of this slot is a
  string.
\item The \emph{nicknames} of the package.  The value of this slot is
  a list of strings.
\item The \emph{use list} of the package.  The value of this slot is a
  proper list of packages that are used by this package.
\item The \emph{used-by list} of the package.  The value of this slot
is a proper list of packages that use this package.
\item The \emph{external symbols} of the package.  The value of this
  slot is a proper list of symbols that are both present in and
  exported from this package.
\item The \emph{internal symbols} of the package.  The value of this
  slot is a proper list of symbols that are present in the package but
  that are not exported.
\item The \emph{shadowing symbols} of the package.  The value of this
  slot is a proper list of symbols.
\end{enumerate}

\subsection{Hash tables}

\subsection{Streams}

\subsection{Functions}
\label{sec-data-representation-functions}

Ordinary (non-generic) SICL functions are instances of the class named
\texttt{simple\-function}.  The class \texttt{simple-function} is
a direct subclass of \texttt{funcallable\-standard-object}.  These two
symbols both have the package \texttt{sicl-clos} as their home package.

In order to obtain reasonable performance, we represent functions in a
somewhat complex way, as illustrated by
\refFig{fig-function-representation}.

\begin{figure}
\begin{center}
\inputfig{fig-function-representation.pdf_t}
\end{center}
\caption{\label{fig-function-representation}
Representation of functions.}
\end{figure}

\refFig{fig-function-representation} shows two functions.  The two
functions were created from the same compilation unit, because they
share the same code object. \seesec{data-representation-code-objects}

A function is represented as a two-word header (as usual) and a
rack with three slots:

\begin{enumerate}
\item The obligatory \emph{stamp}.
\item An \emph{environment}, which is the lexical environment in which
  the function was defined.  We are not giving the details of how the
  static environment is represented here.
\item The \emph{entry point}.  The entry
  point is a \emph{raw address} of an aligned word in the vector
  containing the instructions of the function.  Functions are always
  allocated in the global heap, so the code vector never moves.
  Therefore, this address will never need to be updated.
\end{enumerate}

The static environment contains the \emph{code object} as one of its
elements.

Since raw addresses are word aligned, they show up as \texttt{fixnum}s
when inspected by tools that are unaware of their special
signification.

For a \emph{generic function}, the description of the slots above
applies both to the generic function object itself and to the
\emph{discriminating function} of the generic function.  In addition
to these slots, a generic function also contains other slots holding
the list of its methods, and other information.

When a function is called, there are several possible situations that
can occur:

\begin{itemize}
\item The most general case is when an object of unknown type is given
  as an argument to \texttt{funcall}.  Then no optimization is
  attempted, and \texttt{funcall} is responsible for determining
  whether the object is a function, a name that designates a function,
  or an object that does not designate a function in which case an error is
  signaled.
\item When it can be determined statically that the object called is a
  function (i.e. its class is a subclass of the class
  \texttt{function}), but nothing else is know about it, then an
  \emph{external call} is made.  Such a call consists of copying the
  contents of the \emph{static environment} slot to the predetermined
  place specific to the backend, and then to issue a \emph{call}
  instruction (or equivalent) to the address indicated by the
  \emph{entry point} slot of the function object.  When a function is
  called using a name known at compile time, then the object is known
  to be a function, though it may be a function that signals an error
  because the intended function is undefined.
\item When it can be determined statically that the object being
  called is a function object in the \emph{same compilation unit} as
  the caller, then we can make an \emph{internal call}.  If both the
  caller and the callee are \emph{global functions} (so that the
  static environment contains only a pointer to the code object, then
  it suffices to issue a \texttt{call} instruction (or equivalent) to
  a relative address that can be determined statically. The relative
  address can be chosen so as to avoid type checking of arguments with
  known types.  However, we may not take advantage of this possibility
  unless the \texttt{speed} optimize quality is high, because it makes
  it impossible to redefine a single function in a compilation unit.
\end{itemize}
